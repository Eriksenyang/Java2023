1. thread status : 
  new : start
  runnable : cpu
  terminated : 完毕
  blocked : runnale 获取lock失败时
  waiting : 获取lock wait()时 / notify()激活
  time_waiting : wait(long)时 / wait时间到激活| notify
                 sleep(long)时 / sleep时间到
                 
2.
  private static void testNewRunnableTerminated(){
    Thread t1 = new Thread(() -> {
      loggerA.debut(sop);
    }); 
  }
  
3.Thread pool
  corePoolSize : 处理完还保留在pool中
  maximumPoolSize : core + emerge(处理完就销毁)
  keepAliveTime : emergeThread
  unit时间单位 ：emergeThread
  workQueue　：　Q
  threadFactory　：　
  handler 拒绝策略　：　
  
  ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(2); //capacity : 2
  ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
    2, 3, 0, TimeUnit.MILLISECONDS, queue, 
    r -> new Thread(r, "myThread" + c.getAndIncrement()),
    new ThreadPoolExecutor.AbourtPolicy()
  );
  
  6. sleep() vs wait()
      1.wait() 只能notify. sleep(时间) & wait(时间) 时间到就醒, 也可notify
      2.先拿到lock才能用wait(). sleep()没有这个限制
      3.wait() 放弃lock. sleep()不放弃lock
  7.Lock VS synchronized
    synchronized : 自动解锁   较少功能
    lock :         手动解锁   更多功能(wait())
  
  8.volatile
  
  
    
    
    
    
    
    
    
    
    
    
    
    
    
