https://www.bilibili.com/video/BV1yT411H7YK/

1. thread lifecycle/status : 
  new : start()
  runnable : cpu
  terminated : 完毕
  blocked : runnable 获取lock失败时
  waiting : 获取lock: wait()时 / notify()激活
  time_waiting : 获取lock: wait(long)时 / wait时间到| notify() 激活 
                 runnable: sleep(long)时 / sleep时间到
                 
2.
  private static void testNewRunnableTerminated(){
    Thread t1 = new Thread(() -> {
      loggerA.debut(sop);
    }); 
  }
  
3.Thread pool : submit(task)-> workQueue : 当coreThread 满, workQueue满 才开emergencyThread
  corePoolSize : 处理完还保留在pool中
  maximumPoolSize : core + emerge(处理完就销毁)
  keepAliveTime : emergeThread
  unit时间单位 ：emergeThread
  workQueue　：　设定Queeu容量
  threadFactory　：　
  handler 拒绝策略　：AbourtPolicy(满了报EX), CallerRunsPolicy(满了谁调谁自己跑), DiscardPolicy(丢), DiscardOlestPolicy(丢老的)
  
  ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(2); //workQueue 容量 : 2
  ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
    corePoolSize 2,maximumPoolSize 3,keepAliveTime 0, TimeUnit.MILLISECONDS, queue, 
    r -> new Thread(r, "myThread" + c.getAndIncrement())//计数器,
    new ThreadPoolExecutor.AbourtPolicy()
  );
  
  6. sleep() vs wait()
      wait():      先拿到lock 才wait(),  wait弃锁,  notiy()
      sleep(time): 不用拿lock sleep(),  sleep占锁,  到时间或 notiy()
        
      
  7.Lock VS synchronized : 排他(1把锁), 同步(要等)
    synchronized : 无竞争快  jvm c++  自动解锁   较少功能             
    lock :         有竞争快  jdk java 手动解锁   更多功能(wait()), ReentrantLock(重复功能)(false 不公平)
    
  8. Lock Condition
      c1.await() - 放弃lock, 
      c1.signal() - 唤醒, 加入到workQueue
  
  9.volatile : no thread safe
     1.visable: ok
     2.sequency: ok
     3.automic: no (thread 可以从中间插入, 造成没法执行整段代码)
   
  10.negtive lock:(synchro & lock) thread有lock才去操作,1个有lock, 其他都block. (synchroized 阻止交错, 保证线程安全)
        THread t1 = new Thread(()->
          sychronized(lock){
            account.balance = account.balance - 5;  
          }, t1 );
     positive lock:(AtomicInteger |unsafe) 不要lock, 1个运行, 其他都不断重试直到成功. compareAndSet() + volatile type balance
        Unsafe u = Unsafe.getUnsafe() //修改变量为原子
        BALANCE = u.objectFieldOffset(x.class, variable)
        volatile type balance = x；
        THread t1 = new Thread(()->
          while(true){
            int n = account.balance - 5;
            if(U.compareAndSetInt(account, BALANCE, o, n){ //动态看balance,如果有thread改了原始值就再循环, 直到拿到合适的值 break
              break;
            }
           }
        }, t1);
    
    
    
    
    
    
    
    
    
    
    
    
