158 reliability: publisher:生产者确认机制 | MQ: 持久化 | consumer: 消费者确认机制

    1. RabbitMQ : 发消息给生产者 
        publisher confirm : msg成功发送到exchage : ack
                            msg未成功发送到exchage : nack
        publisher return :  msg成功发送到exchage, 未到queue. ack & 路由失败原因
        
    2. SpringAMQP
        1. 生产者 application.yml                            异步                                             ReturnCallback提供信息
            spring / rabbitmq/ publisher-confirm-type: correlated / pubbisher-return: true / template/ mandatory: true
        
        2.单例的ReturnCallback： 每个RabbitTemplate只有1个, 所以要在项目启动时配置
          @Slf4j
          @Configuration
          public class commonConfig implements ApplicationContextAware{
            @Override
            public void setApplicationContext(ApplicationContext applicationContext) throws BeansException{
              RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);
                                               //                     原因
              rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) ->{
                log.error(“msg 发送失败”, message.toString(), replyCode, replyText, exchange, routingKey )});
            }          
          }

        3. 测试
            @RunWith(SpringRunner.class)
            @SpringBootTest
            @Slf4j
            public class SpringAmqpTest{
              @Autowired
              private RabbitTemplate rabbitTemplate;
              @Test
              public void testSendMsg2SimpleQueue() throws InterruptedException{
                String queueName = "simple.queue";
                String message = "hello";
                CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
                correlationData.getFuture().addCallback(
                  result) ->{  //成功
                    if(result.isAck){
                      log.dubug(“消息发送成功”,correlationData.getiId());
                    }else{ //nAck
                      log.error("error", correlationData.getId());
                      //重发
                    }
                  }, ex ->{ //失败
                    log.error("error", ex);
                });

                rabbitTemplate.convertAndSend(queueName, routingKey ,message, correlationData); //发送
              }
            }

        4.ConfirmCallback
            @Test
            public void testSendMessage2SimpleQueue() throws InterruptedException{
              String msg = "hi, spring amqp";
              CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
              correlationData.getFuture().addCallback( //将来的消息
                result -> { if(result.isAck()){                                          
                              log.dubug(“消息发送成功”,correlationData.getiId());
                            }else{
                              log.error(“消息发送失败”,correlationData.getId(),  result.getReason());
                            }
                           }, 
                           ex -> log.error(“消息发送异常”,correlationData.getId(),  result.getReason())  
              );
              rabbitTemplate.convertAndSend(msg, correlationData); //发消息
            }

    消息持久化(40:00) persistent
       1.  Cosumer
        @Configuration
        public class CommonConfig{ 
            @Bean
            public DirectExchange simpleExchange(){ //        1. exchange持久化
                                        //名字， 持久化， 是否自动删除，
                return new DiectExchange("name", true, false);
            }
            @Bean   
            public Queue simpleQueue(){  //                  2. queue 队列持久化
                return QueueBuilder.durable("name").build();
            }
        }
        
       2. publisher  
            @RunWith(SpringRunner.class)
            @SpringBootTest
            @Slf4j
            public class SpringAmqpTest{
               @Autowired
               private RabbitTemplate rabbitTemplate;
                @Test
                public void testDurableMessage(){
                    Message msg = MessageBuilder.withBody("msg".getBytes(StandardCharasets.UTF_8))
                                   .setDeliveryMode(MessageDeliveryMode.PERSISTENT)  //  3.msg  消息持久化
                                   .build();
                    rabbitTemplate.convertAndSend("simple.queue", msg); //发消息
                }
            }

  消费者消息确认(53:00)
     1. manual
     2. auto: 
     3. none:
     cosummer : application.yml
      spring:/ rabbitmq/ listener? simple/ prefetch: 1/acknowledge-mode: auto
      
   失败重试（1：02）
      1.在本地retry
          cosummer : application.yml                      //重试                               1s        等待时间为3的倍数    最多3次                                                           //
          spring:/ rabbitmq/ listener? simple/ prefetch: 1/retry/ enable: true/ initial-interval: 1000/multiplier:3/max-attempts:3/ stateless: true
      2.消费者失败消息处理 MessageRecoverer
         RejectAndDontRequestRecoverer ： reject,default
         ImmediateRequeueMessageRecoverer: 重入Q
         RepublishMessageRecoverer: 重发到指定exchange
         
         1.error msg exchange, queue, binding
           consummer 
           @Configuration
           public class ErrorMessageConfig{
            @Bean
            public DirectExchange errorMsgExchange(){
                return new DirectExchange("error.dirct");
            }
            @Bean
            publc Queue errorQ(){
                return new Queue("error.queue", true);
            }
            @Bean
            public Binding errorBinding(){                                        //routingKey
                return BindingBuilder.bind(errorQ().to(errormsgExchange())).with("error");
            }
            @Bean  //      2.republishMsgRecoverer
            public MessageRecoverer republishMsgRecoverer(RabbitTemplate rabbitTemplate){
                return new RepublishMssageRecoverer(rabbitTemplate, "error.dirct", "error");
            }
           } 

            
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
